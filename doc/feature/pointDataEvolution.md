Evolution of data at a point over time {#pointDataEvolution}
======================================

One of the features that would be extremely useful for scientists is the
ability to obtain the evolution of the data at a specific point over time.
For example, they could load a current report and compute the LFP for a specific
target, and once they have their full volume, they could focus on a specific
point of the scene (e.g. a voxel), and obtain a 2D curve showing the evolution
of voltage at that point for the whole available time span.

## Requirements

* The new feature will be provided as a separate command line tool.
* Users should be able to specify the coordinates of a 3D point as input.
* As output, users will obtain a series of values corresponding to the evolution
  of the data at that specific point over time, one value per simulation frame,
  using always the default report dt.
* The computation should be independent from the voxelization step, as the
  point for which the values will be computed should not be limited to discrete
  voxels, but a continuous 3D space.
* This feature is not related to the (online) streaming of values. It is just an
  additional (offline) step that is done after loading and processing the data,
  to report the information in a more localized way.

## Implementation

The core of the computation is already present in Fivox in the form of functors,
that take a 3D point as a parameter and, based on the use case and the different
types of functors available, return a value that is the result of evaluating the
existing events.

To make the computation of these values easy from a user point of view, we need
to expose the usage of the functors in a separate step as an independent
application.

For that reason, the 'voxelize' app will need to be refactored to extract the
common parts into a superclass that will be used as base for all the
applications.

## API

    class CommandLineApplication
    {
        virtual program_options getHelp(); // all generic options (including volume URI details)
        Vector2ui getFrameRange();
        ImageSourcePtr getImageSource();
    }

    class Voxelize : CommandLineApplication
    {
        program_options getHelp(); // adding voxelize-specific options
        sample(...); // existing function
    }

    class SamplePoint : CommandLineApplication
    {
        program_options getHelp(); // adding application-specific options (3d point)
        write( Vector3f point, Vector2ui frameRange, string filename );
    }

## Usage

The usage of the C++ app would be as:

    sample-point --volume "fivox://BlueConfig?target=Column&dt=0.1" --point [x, y, z] --frame[s] "0 10" [or alternatively, --time[s] "0 100"] --output data.txt

And the plotting tool:

    plot2D.py --input data.txt --output graph.png

If the output file name is not specified, an interactive matplotlib widget will
show, allowing the user to navigate through the graph and explore the different
values.

Potentially, both steps could be combined into one wrapping tool that runs both
steps one after the other.

## File format

The resulting plot should reflect the time evolution on the X axis, and the data
values on Y. Therefore, the C++ tool will need to generate files in the
following format:

* One line per timestep
* Each of the lines containing the timestamp (ms) and value (output unit),
  separated by whitespaces
* An optional header containing the information about the way the data was
  generated (Fivox volume URI, dt, frame range and point coordinates)

Example:
    # File generated by the sample-point tool:
    # - Format: timestamp value
    # - Fivox URI: fivox://BlueConfig?report=soma&functor=lfp
    # - dt: 0.1
    # - Frame range: [          0      10 ]
    # - Point sampled: [          0          0          0 ]

    0 -0.631731
    0.1 -0.631102
    0.2 -0.630923
    0.3 -0.630797
    0.4 -0.630697
    0.5 -0.630615
    0.6 -0.630545
    0.7 -0.630486
    0.8 -0.630434
    0.9 -0.63039

## Issues

### 1: Why should we create a new application?

The alternative is to overload the 'voxelize' app. Since we don't want to depend
on the voxelization step or the volume creation for the computation of the
values, we will create a new application that will have some parts in common
with other apps, such as the volume URI evaluation or the frame/time ranges to
compute.

As for the name of the new application, here are some suggestions:
values-over-time, values-at-point, data-over-time, data-evolution, sample-point,
extract-timeseries... or any combination of the aforementioned.

### 2: How to output the resulting values?

There are several possibilities:

1. Writing to file
2. Plot directly as a 2D graph
3. Stream through ZeroEQ

Option 2 would require the integration of a plotting library in C++. Option 3
adds complexity that is not needed now, as it would only make sense for
the streaming case, which is not a priority at the moment.

Resolved: For the sake of simplicity, we will start with a basic use case in
which we write from the C++ app to a file and then add a separate step to create
the 2D plot using a simple library in Python (matplotlib).

### 3: File format: binary or ASCII?

Resolved: For readability, and since the file structure is simple enough and
there are not many potential bottlenecks in read/write performance, the format
will be ASCII.
