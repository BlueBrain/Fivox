Documentation {#documentation}
============

[TOC]

This document describes the basic structure and provides pointers to
auxilary documentation.

## Directory Layout

* [CMakeLists](https://github.com/BlueBrain/Hello/blob/master/CMakeLists.txt):
  top-level CMake file, delegates most of its work to the CMake subdirectory.
* [CMake](https://github.com/Eyescale/CMake#readme): subdirectory
  included using git externals. See below for details.
* hello: Core library of the project.
* apps: Applications delivered with the project.
* tests: Unit tests
* doc: Doxygen and other documentation.

## CMakeLists

The top-level CMakeLists is relatively simple due to the delegation of
details into the CMake external. It starts with the project setup which
defines the project name and includes the CMake/common git external
defined in
[.gitexternals](https://github.com/BlueBrain/Hello/blob/master/.gitexternals)

@snippet CMakeLists.txt Setup

The GitExternal script clones and updates the given git repository to
the given revision. To update the revision to the latest master, it also
provide a 'make update' target.

- - -

Before including the Common cmake setup, the project versions are
defined:

@snippet CMakeLists.txt Versioning

The API version is composed of major.minor.patch. Major is increased
every time the API is broken, that is, users of the software need to
change something in their implementation to compile. Minor is increased
for each release with new features or optimizations which do not break
the official programming interface. Unstable prototype software uses 0
as major and is allowed to break the API between minor versions (since
it does not have an official 1.0 API). A patch release fixes only bugs
without breaking the ABI. It never introduces new functionality.

The ABI version (RELEASE_VERSION) is the binary interface, that is, the
shared library interface. It has to be increased every time the library
changes, e.g., by introducing new functions or changing the memory
layout of a class. A patch release must be ABI compatible. A minor
release may be ABI compatible -- Test it by replacing the .so for an
existing application!  A major release necessarily breaks the ABI.

LAST_RELEASE is used by a few Common targets, e.g., tarball.

- - -

Then the now-famous Common cmake script and not-so-famous FindPackages
is included:

@snippet CMakeLists.txt Scripts

Some project-specific information needs to be set for Common to generate
the documentation and packages. Common is documented in its own
[Readme](https://github.com/Eyescale/CMake#readme). FindPackages is
generated by Buildyard based on the declared dependencies for the
project, and is used as a single include to find all dependencies.

- - -

CMake allows for hierarchical configuration using add_subdirectory. In
this template project, a library, an application and unit tests sit in
their respective subdirectories:

@snippet CMakeLists.txt Targets

- - -

After all targets have been processed, doxygen can run (on the installed
targets) and CPack can do its magic:

@snippet CMakeLists.txt Footer

## CMake

All BBP projects rely on a common
[CMake repository](https://github.com/Eyescale/CMake) which provides
sensible defaults for compilation, documentation and packaging. It is
integrated as a CMake/common subtree as described in the
[Readme](https://github.com/Eyescale/CMake#readme).

## Hello Library

Naming consistency is very important for the automation. Use the
lower-case project name for the directory and for the project namespace,
e.g., "hello". This is important for include names inside and outside
the project. Use the capitalized project name as the library name. This
is important for the generated PackageConfig, used by downstream
packages to "find_package(Hello)". To configure the library build, the
hello CMakeLists sets all variables picked up by the common
[common_library](https://github.com/Eyescale/CMake/blob/master/CommonLibrary.cmake),
which builds and installs the library and public headers to
include/name:

@include hello/CMakeLists.txt

Each library needs to have the following files, which are consequently
created automatically by Common.cmake:

* version.h: exports the project API and ABI version for downstream
  projects. Common.cmake also creates the corresponding version.cpp
* defines.h: Project compile-time definitions, i.e., which optional
  dependencies are available. Includes the actual os-specific defines
  file generated by FindPackages.cmake.
* hello.h: A meta include including all public headers, generated by
  common_library

All generated files are appended to the COMMON_INCLUDES and
COMMON_SOURCES cmake variables.

## World Application

The only application of this template project is in apps/rule, and is
configured using
[common_application](https://github.com/Eyescale/CMake/blob/master/CommonApplication.cmake),
which is similar to build_library:

@include apps/rule/CMakeLists.txt

## Unit tests

Unit tests are very important. Therefore our extensive example has
[100% test coverage](CoverageReport/index.html). Again, the unit tests
configuration relies largely on a common cmake script:

@include tests/CMakeLists.txt
